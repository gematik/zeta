ingress_controller:
  enabled: false

management_service:
  enabled: false

service_mesh:
  enabled: false

authserver:
  hostname: ""
  http_enabled: true

pepproxy:
  image:
    pullPolicy: Always
  nginxConf:
    generateConfigMap: true

    pepIssuer: http://authserver/auth/realms/zeta-guard

    locations: |-
          location / {
            root /usr/share/nginx/html;

            pep                  on;
          }
      # Proxy OAuth Authorization Server metadata to Keycloak (demo)
      # Served as: http://<host>/.well-known/oauth-authorization-server
      # Target:   http://authserver/auth/realms/zeta-guard/.well-known/zeta-guard-well-known
      location = /.well-known/oauth-authorization-server {
        proxy_pass http://authserver/auth/realms/zeta-guard/.well-known/zeta-guard-well-known;
        proxy_http_version 1.1;
        }

# DB mode switch:
# - bitnami: local using Bitnami subchart service/secret
# - operator: staging/dev/prod using Zalando Postgres Operator
databaseMode: bitnami
postgresql:
  image:
    repository: bitnamilegacy/postgresql
  enabled: true
  auth:
    username: keycloak
    password: devpassword
    database: keycloak
  primary:
    persistence:
      enabled: false

# Which cert-manager ClusterIssuer to use for TLS on the Ingress (default)
clusterIssuer: "letsencrypt-cd"

opa:
  enabled: true

# OPA policy/data configuration (example)
# Uncomment and adjust to override policy and allowed scopes via values
opaPolicy:
  # Enable console decision logs in OPA
  logDecisions: true
  # Rego v1 syntax
#  policyRego: |
#    package zeta.authz
#    default allow := false
#    allow if {input.path == ["users"] input.method == "POST"}

admissionWebhooks:
  certManager:
    enabled: true
